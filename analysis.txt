1. My implementation follows the algorithm described by the book by refactoring into functions to avoid redundancy. The vector data, is sorted by x and y and then passed onto a function 'proc' that handles the recursive procedure. If the size of the data is less than or equal to three, then the brute force method is called. Otherwise, the vector that is sorted by x is split up and sorted recursively. Once the smallest distance between two points in each half is found, then the middle 'strip' Ystrip is looked at. This is done by analyzing all points whose x distance squared is less than or equal to the current best sorted by Y coordinate this time. Once this strip is found, it is searched in blocks of size 7 (i.e. for every point, the next seven points are looked at) in order to find a smaller distance. The best Outcome 'delta' that has been found is returned.

2. xSorted is a vector that contains the data sorted by X. This vector is split into two vectors leftHalf and rightHalf which are passed down recursively, each representing the left and right halves of the original vector. ySorted is a vector that contains the same points sorted by Y. This vector is split into Yleft and Yright. These vectors are still sorted by y, but split into the points which are to the left and right of the midpoint. These vectors are passed down recursively. midPoint is the middle point according to x and delta is the current best outcome, as described in the book.

3.The value chosen as the threashold for the brute force is 3. The ideal value according to data gathering (as shown below ) is . The value of 3 was chosen because of the book's description of the algorithm
4.
N       brute-force       divide-and-conquer
1,000    
2,000    
4,000    
8,000    
16,000     
32,000     
64,000     
128,000    
256,000    
512,000    
1,000,000    
2,000,000    
4,000,000    
8,000,000    
16,000,000     
32,000,000     
